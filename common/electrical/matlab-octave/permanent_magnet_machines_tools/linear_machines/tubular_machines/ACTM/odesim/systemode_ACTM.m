function varargout = systemode_ACTM(t, x, design, simoptions)
% systemode_ACTM: solves the right had side of the differential
% equations for the combined snapper and buoy system
%
% Syntax:
%
% [dx] = systemode_ACTM(t, x, design, simoptions)
% 
% [..., FBDh] = ] = systemode_ACTM(t, x, design, simoptions)
%     
% [..., bouyancy_force] = systemode_ACTM(t, x, design, simoptions)
% 
% [..., excitation_force_heave] = systemode_ACTM(t, x, design, simoptions)
% 
% [..., excitation_force_surge] = systemode_ACTM(t, x, design, simoptions)
% 
% [..., Hrad_force] = systemode_ACTM(t, x, design, simoptions)
% 
% [..., Srad_force] = systemode_ACTM(t, x, design, simoptions)
% 
% [..., dpsidxR] = systemode_ACTM(t, x, design, simoptions)
% 
% [..., EMF] = systemode_ACTM(t, x, design, simoptions)
% 
% [..., Ffea] = systemode_ACTM(t, x, design, simoptions)
% 
% [..., Fs] = systemode_ACTM(t, x, design, simoptions)
% 
% [..., Ffea_surge] = systemode_ACTM(t, x, design, simoptions)
%
% Input
%
% x is a vector of values of the state of the sytem at time t. The members
% of x are the following:
%
% x(1) = Buoy position - heave xBh
% x(2) = Bouy velocity - heave vBh
% x(3) = Bouy position - surge xBs
% x(4) = Buoy velocity - surge vBs
% x(5) = I, coil current in phase 1
% x(6) = I, coil current in phase 2
% x(7) = I, coil current in phase 3
% x(8) = I(1) (heave)
% x(9) -- x(N) = I(2) - I(N-6) (heave)
% x(N+1) -- x(N+M) = I(1) - I(M) (surge)
%
% design is a standard machine design structure popluated with all the
% necessary information to perform the simulation. 
%
% simoptions.BuoySim.BuoyParameters is a parameters structure containing information about the buoy.
% It should contain the following members:
%
%   Halpha - 
%   Hbeta - 
%   Salpha - 
%   Sbeta - 
%   drag_coefficient - coefficient of drag on the buoy
%   a - radius of the buoy
%   g - local gravitational constant (in case we deploy on Mars or Moon in future)
%   rho - density of seawater (see above)
%
% simoptions.BuoySim.SeaParameters is a structure containing information about the see conditions
% being used in the simulation. It should contain the following members:
%
%   amp - vector of wave amplitudes for each wave sinusoid being applied
%   phase - vector of phase values for each sinusoid being applied
%   sigma - vector of angular frequencies for each sinusoid
%   wave_number - 
%
% simoptions is a structure containing some further simulation parameters
% 
%
% Output:
%
%

    % Change the x members into more useful variables names, MATLAB will
    % optimise away any memory penalty associated with this I think
    xBh = x(1);
    vBh = x(2);
    xBs = x(3);
    vBs = x(4);
    Icoils = [x(5); x(6); x(7)];

    % Initialize dx with zeros
    dx = zeros(size(x));

    % The differentials of the positions are the velocities
    dx(1,1) = vBh;
    dx(3,1) = vBs;

    % Declare a constant to make it easier to change the number of columns
    % in x and dx, column N is the starting column for the hydrodynamic
    % results
    N = 8;

    %**********************************************************************
    % Determines the forces acting within the machine, and other important
    % machine outputs

    % The current desity to which the polynomials should be fitted is the
    % average current density over the whole coil area. This is calculated
    % as the total current passing througn the area divided by the area.
    %J = design.CoilTurns .* Icoils ./ design.CoilArea;

    % next we determine the relative position of the armature and field in
    % order to determine forces and flux linkage

    % first determine xT from the new tether length, change in translator
    % vertical position will be change in distance from hawser to buoy, i.e
    % the change in tether length
    xT = sqrt((xBh+simoptions.BuoySim.tether_length).^2 + xBs.^2) - simoptions.BuoySim.tether_length;

    % convert to relative position
    xR = xT ./ design.Wp;
    
    pos = -[xR+(1/3); xR; xR-(1/3)];
    
    % Find dpsidxR from a polynomial fitted to data generated by derivest
    % function
    %dpsidxR = polypsidot_ACTM(design, pos);
    dpsidxR = slmpsidot_linear(design, pos, design.Wp);
    
    % First find unit vector in the direction pointing from hawser to the buoy
    unitv = [simoptions.BuoySim.tether_length+xBh, xBs] / norm([simoptions.BuoySim.tether_length+xBh, xBs]);

    % Then find dot product of heave and surge velocities with unit vector
    % to get correct direction and magnitude of translator velocity
    vT = dot(unitv, [vBh, vBs]);
    
    vA = -vT;

    % determine the emf (voltage) in the coils, - vR * dpsi / dx
    EMF = - vA .* dpsidxR;

    % find the derivative of the coil current
    dx(5:7,1) = (EMF - Icoils .* design.R) ./ design.L;
    
    % determine the forces due to the magnets and electrical forces at
    % the relative position xR with the current values of J. Forces are
    % fitted to a 1m stack length, so we adjust for this by multiplying by
    % ls, the actual stack length in m
    %Ffea = sum(intbpolyshearforce_AC(design, J, pos)) .* design.Poles(1);
    
    % ensure force is zero at xR = 0
%     if abs(roundoff(xT ./ design.Taup, 5)) == 0
%         Ffea = 0;
%     end

    % determine the forces due to the magnets and electrical forces at
    % the relative position xR absed on the coil current and rate of change
    % of flux linkage w.r.t. xR at this point.
    Ffea = sum(Icoils .* -dpsidxR) .* design.Poles(1);

    %  Calculating the proportion that the machine forces are producing on
    %  surge and in heave. Do this by multiplying unit vector in direction
    %  of hawser to buoy by total forces. This results in new vector:
    %
    %               FfeaVec = [Ffea_heave, Ffea_surge]
    %
    %  Which should also have forces in the right directions. The FEA
    %  forces are calculated for the coils, therefore when the translator
    %  is moving up, Ffea is also acting upwards. We must reverse their
    %  direction to get the forces acting on the translator (and buoy).
    FfeaVec = -Ffea * unitv;

    % Calculate the drag forces on the translator
    % Fdrag = sign(vT) .* 0.5 .* realpow(vT,2) .* simoptions.BuoySim.BuoyParameters.rho .* design.Cd .* design.DragArea;

    % ********************************************************************
    % Buoy Acceleration, these calcs assume all of the mass is in the buoy,
    % this should be a reasonable assumption provided the mass of the
    % translator is not too significant in comparison

    Fexternal(1) = FfeaVec(1);
    Fexternal(2) = FfeaVec(2);
    
    % Determine the buoy/sea interaction forces and derivatives
    [dx, bouyancy_force, ...
        excitation_force_heave, ...
        excitation_force_surge, ...
        radiation_force_heave, ...
        radiation_force_surge, ...
        FBDh, FBDs] = buoyodesim(t, x, dx, xBh, vBh, vBs, simoptions, Fexternal);

    % ************************************************************************

    % Now assign the outputs
    varargout{1} = dx;

    % To record the forces
    if nargout > 1
        
        % per-coil induced voltage 
        varargout{2} = EMF;
        % total electromagnetic forces acting on armature
        varargout{3} = Ffea;
        % vertical displacement of the translator  
        varargout{4} = xT;
        % vertical velocity of the translator
        varargout{5} = vT;
        % heave component of generator forces
        varargout{6} = FfeaVec(1);
        % surge component of generator forces
        varargout{7} = FfeaVec(2);
        % buoy drag forces in heave
        varargout{8} = FBDh;
        % buoy drag forces in surge
        varargout{9} = FBDs;
        % simple buoyancy force
        varargout{10} = bouyancy_force;
        % excitation force in heave
        varargout{11} = excitation_force_heave;
        % excitation force in surge
        varargout{12} = excitation_force_surge;
        % radiation force in heave
        varargout{13} = radiation_force_heave;
        % radiation force in surge
        varargout{14} = radiation_force_surge;
        % rate of change of flux linkage with displacement 
        varargout{15} = dpsidxR;
        
    end

end

